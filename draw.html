<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>画板</title>
    <style>
        canvas {
            border: 1px solid black;
        }

    </style>
</head>

<body>
    <canvas id="canvas" width="500" height="500"></canvas>
    <div>
        <div>
            <button id="pen-button">笔</button>
            <button id="eraser-button">橡皮</button>
        </div>
        <div>
            <input type="color" id="color" />
            <input type="range" id="line-width" min="1" max="100" value="5" />
        </div>
        <div>
            <button id="undo-button">撤销</button>
            <button id="redo-button">重做</button>
            <button id="clear-button">清空</button>
            <button id="download-button">下载</button>
        </div>
        <div>
            <button id="rect-button">长方形</button>
        </div>
    </div>

    <script>
        // 定义画板类
        class DrawingBoard {
            constructor(canvas, context) {
                this.canvas = canvas;
                this.context = context;

                // 为Canvas绑定事件监听器
                canvas.addEventListener("mousedown", this.onMouseDown.bind(this));
                canvas.addEventListener("mousemove", this.onMouseMove.bind(this));
                canvas.addEventListener("mouseup", this.onMouseUp.bind(this));

                // 定义默认画笔样式
                this.lineColor = "black";
                this.lineWidth = 5;
                this.context.lineCap = "round";
                this.context.globalCompositeOperation = "source-over";

                // 初始化变量
                this.isDrawing = false;
                this.lastX = 0;
                this.lastY = 0;
                this.imgData = null;

                this.undoStack = [];
                this.redoStack = [];

                this.currentShape = "pen";
                this.shapeStartX = 0;
                this.shapeStartY = 0;
            }

            onMouseDown(event) {
                this.isDrawing = true;
                this.context.strokeStyle = this.lineColor;
                this.context.lineWidth = this.lineWidth;
                this.lastX = event.offsetX;
                this.lastY = event.offsetY;
                this.saveCanvas();
                this.undoStack.push(this.imageData);
                this.redoStack = [];

                if (this.currentShape !== "pen") {
                    this.shapeStartX = event.offsetX;
                    this.shapeStartY = event.offsetY;
                }
            }

            onMouseMove(event) {
                if (!this.isDrawing) return;

                if (this.currentShape !== "pen") {
                    this.restoreCanvas();
                    const rectWidth = event.offsetX - this.shapeStartX;
                    const rectHeight = event.offsetY - this.shapeStartY;
                    this.context.strokeRect(this.shapeStartX, this.shapeStartY, rectWidth, rectHeight);
                } else {
                    this.context.beginPath();
                    this.context.moveTo(this.lastX, this.lastY);
                    this.context.lineTo(event.offsetX, event.offsetY);
                    this.context.stroke();

                    this.lastX = event.offsetX;
                    this.lastY = event.offsetY;
                }
            }

            onMouseUp(event) {
                this.isDrawing = false;
                if (this.currentShape === "rect") {
                    const rectWidth = event.offsetX - this.shapeStartX;
                    const rectHeight = event.offsetY - this.shapeStartY;

                    this.context.strokeRect(this.shapeStartX, this.shapeStartY, rectWidth, rectHeight);
                }
            }

            saveCanvas() {
                this.imgData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
            }

            restoreCanvas() {
                this.ctx.putImageData(this.imgData, 0, 0);
            }

            setShape(shape) {
                this.context.globalCompositeOperation = "source-over";
                this.currentShape = shape;
            }

            setLineColor(color) {
                this.lineColor = color;
            }

            setLineWidth(width) {
                this.lineWidth = width;
            }

            setLineCap(style) {
                this.context.lineCap = style;
            }

            setEraser() {
                this.setShape("");
                this.context.globalCompositeOperation = "destination-out";
            }

            undo() {
                if (this.undoStack.length === 0) return;
                this.redoStack.push(this.context.getImageData(0, 0, this.canvas.width, this.canvas.height));
                this.context.putImageData(this.undoStack.pop(), 0, 0);
            }

            redo() {
                if (this.redoStack.length === 0) return;
                this.undoStack.push(this.context.getImageData(0, 0, this.canvas.width, this.canvas.height));
                this.context.putImageData(this.redoStack.pop(), 0, 0);
            }

            saveAsImage() {
                const link = document.createElement("a");
                link.download = "paint.png";
                link.href = this.canvas.toDataURL();
                link.click();
            }

            clear() {
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.undoStack = [];
                this.redoStack = [];
            }
        }

        const __main = function () {
            // 创建Canvas画布元素
            const canvas = document.getElementById("canvas");
            const context = canvas.getContext("2d");

            // 创建画板对象
            const drawingBoard = new DrawingBoard(canvas, context);

            const eraserButton = document.getElementById("eraser-button");
            eraserButton.addEventListener("click", () => {
                drawingBoard.setEraser();
            });

            const rectButton = document.getElementById("rect-button");
            rectButton.addEventListener("click", () => {
                drawingBoard.setShape("rect");
            });

            const penButton = document.getElementById("pen-button");
            penButton.addEventListener("click", () => {
                drawingBoard.setShape("pen");
            });

            const undoButton = document.getElementById("undo-button");
            undoButton.addEventListener("click", () => {
                drawingBoard.undo();
            });

            const redoButton = document.getElementById("redo-button");
            redoButton.addEventListener("click", () => {
                drawingBoard.redo();
            });

            const clearButton = document.getElementById("clear-button");
            clearButton.addEventListener("click", () => {
                drawingBoard.clear();
            });

            const downloadButton = document.getElementById("download-button");
            downloadButton.addEventListener("click", () => {
                drawingBoard.saveAsImage();
            });

            const color = document.getElementById("color");
            color.addEventListener("change", (event) => {
                drawingBoard.setLineColor(event.target.value);
            });

            const lineWidth = document.getElementById("line-width");
            lineWidth.addEventListener("change", (event) => {
                drawingBoard.setLineWidth(event.target.value);
            });
        };
        __main();
    </script>
</body>

</html>
